<!DOCTYPE html>
<html>

<head>
	<title>OpenFinch dashboard</title>
	<style>
		/* Sets the default background color and text color for the body */
		body {
			background-color: lightsteelblue;
			color: hsl(0, 0%, 10%);
		}

		/* Updates the body background color, text color, and font for readability */
		body {
			background-color: #F5F5F5;
			color: #333;
			font-family: Arial, sans-serif;
		}

		/* Styles the main heading, center aligns the text, and adds vertical padding */
		h1 {
			color: #333;
			text-align: center;
			padding: 20px 0;
		}

		/* Adjusts the background and text color for dark mode preference */
		@media (prefers-color-scheme: dark) {
			body {
				background-color: #0f1010;
				color: lightblue;
			}
		}

		/* Sets a responsive width for images, makes their height adjust automatically, and centers them horizontally */
		img {
		    display: block;
		    max-width: 90%;          /* Image will occupy up to 90% of the container's width */
		    height: auto;            /* Height is automatically adjusted to maintain the aspect ratio */
		    margin-left: auto;       /* Horizontally centers the image */
		    margin-right: auto;      /* Horizontally centers the image */
		}

		.control-container {
			display: flex;
			flex-wrap: wrap;
			max-width: 500px;
			min-width: 300px;
			margin: 0 1vw; /* 5% of the viewport width on the left and right */
		}

		.controls-wrapper {
			display: flex;
			justify-content: space-evenly; /* This will space out the child divs evenly */
			flex-wrap: wrap; /* This allows the containers to wrap onto the next line on smaller screens */
		}
		
		.control-wrapper {
			display: flex;
			justify-content: space-between;
			align-items: center;
			width:  100%;
			margin-bottom:  10px; /* Space between controls */
		}

		.control-wrapper label {
			flex:  1;
			margin-right:  10px;
		}

		.control-wrapper input[type=range] {
			flex:  2;
			width:  100%;
		}

		.control-wrapper span {
			flex:  1;
			text-align: right;
		}
		/* Styles the container of slider elements to form a row with aligned items */
		.slider-decorated {
			display: flex;
			justify-content: space-between;
			/* align-items: center; */
			width: 100%;
		}

		/* Sets the label width and its margins and padding for alignment */
		.slider-decorated label {
			max-width: 50%;
			margin: 0;
			padding: 0;
			text-align: right;
		}

		/* Adjusts the range input width to occupy proportion of its container without additional margins or padding */
		.slider-decorated input[type=range] {
			width: 300px;
			/* margin: 0; */
			/* padding: 0; */
			align-items: left;
		}

		/* Defines the width, margin, and padding for the span that displays the slider's value */
		.slider-decorated span {
			/* width: 10%;
			margin: 0;
			padding: 0; */
			text-align: left;
		}

		/* Styles the container of checkbox elements to form a row with aligned items */
		.checkbox-decorated {
			display: flex;
			justify-content: space-between;
			/* align-items: center; */
			width: 100%;
		}

		/* Styles the checkbox label */
		.checkbox-decorated label {
			max-width: 50%;
			margin: 0;
			padding: 0;
			text-align: right;
		}

		/* Style the checkbox to a proportion of its container */
		.checkbox-decorated input[type=checkbox] {
			/* width: 10%; */
			/* margin: 0; */
			/* padding: 0; */
			align-items: right;
		}

		/* Style the span that displays the checkbox's value */
		.checkbox-decorated span {
			/* width: 50%; */
			/* margin: 0; */
			/* padding: 0; */
			text-align: left;
		}

		/* Styles the generic div with margin, padding, and border properties */
		/* div {
			margin: 20px 0;
			padding: 20px;
			border: 1px solid #ddd;
			border-radius: 5px;
		} */

		/* Applies a universal styling for range and checkbox input types */
		/* input[type=range], input[type=checkbox] {
			width: 100%;
			padding: 10px;
			box-sizing: border-box;
		} */


		/* Removes the focus outline from the range inputs */
		input[type=range]:focus {
			outline: none;
		}

		/* Customizes the focus state of webkit slider runnable track */
		/* input[type=range]:focus::-webkit-slider-runnable-track {
			background: #367ebd;
		} */


	</style>
</head>

<body>
	<h1>OpenFinch dashboard</h1>
	<div class="controls-wrapper">
		<div class="control-container">

			<div>
				<label for="capture_mode">Capture Mode:</label>
				<select id="capture_mode" name="capture_mode">
					<option value="preview">Preview</option>
					<option value="video">Video</option>
					<option value="still">Still</option>
				</select>
			</div>

			<div class="checkbox-decorated">
				<label for="cam_mode">Camera Mode:</label>
				<input type="checkbox" id="cam_mode" name="cam_mode">
				<span id="cam_mode_value">triggered</span>
			</div>

			<br>
			
			<!-- <div>
				<label for="power_line_frequency">Power Line Frequency:</label>
				<select id="power_line_frequency" name="power_line_frequency">
					<option value="0">Disabled</option>
					<option value="1">50 Hz</option>
					<option value="2">60 Hz</option>
				</select>
			</div> -->
			
			<!-- <div>
				<label for="exposure_auto">Exposure Auto:</label>
				<select id="exposure_auto" name="exposure_auto">
					<option value="1">Manual Mode</option>
					<option value="3">Aperture Priority Mode</option>
				</select>
			</div>
			
			<div class="slider-decorated">
				<label for="backlight_compensation">Backlight Compensation:</label>
				<select id="backlight_compensation" name="backlight_compensation">
					<option value="0">0</option>
					<option value="1">1</option>
					<option value="2">2</option>
				</select>
			</div> -->

			<div>
				<label for="sweep">Sweep LED time:</label>
				<input type="checkbox" id="sweep" name="sweep">
			</div>

			<div class="slider-decorated">
				<label for="LED_TIME">LED time:</label>
				<input type="range" id="LED_TIME" name="LED_TIME" min="0" max="8333" step="10" value="400">
				<span id="LED_TIME_value">400</span>
			</div>
			
			<div class="slider-decorated">
				<label for="WAVE_DURATION">Wave duration:</label>
				<input type="range" id="WAVE_DURATION" name="WAVE_DURATION" min="0" max="50000" step="100" value="8000">
				<span id="WAVE_DURATION_value">8000</span>
			</div>
			
			<div class="slider-decorated">
				<label for="LED_WIDTH">LED Width:</label>
				<input type="range" id="LED_WIDTH" name="LED_WIDTH" min="0" max="1500" step="1" value="4">
				<span id="LED_WIDTH_value">4</span>
			</div>

			<!-- <div class="slider-decorated">
				<label for="JPEG_QUALITY">JPEG quality:</label>
				<input type="range" id="JPEG_QUALITY" name="JPEG_QUALITY" min="0" max="100" step="1" value="25">
				<span id="JPEG_QUALITY_value">25</span>
			</div> -->

		</div>

		<div class="control-container">

			<!-- <div class="slider-decorated">
				<label for="exposure_absolute">Absolute exposure:</label>
				<input type="range" id="exposure_absolute" name="exposure_absolute" min="1" max="5000" step="1" value="66">
				<span id="exposure_absolute_value">66</span>
			</div>

			<div class="slider-decorated">
				<label for="brightness">Brightness:</label>
				<input type="range" id="brightness" name="brightness" min="-64" max="64" step="1" value="0">
				<span id="brightness_value">0</span>
			</div>
			
			<div class="slider-decorated">
				<label for="contrast">Contrast:</label>
				<input type="range" id="contrast" name="contrast" min="0" max="64" step="1" value="32">
				<span id="contrast_value">32</span>
			</div>
			
			<div class="slider-decorated">
				<label for="saturation">Saturation:</label>
				<input type="range" id="saturation" name="saturation" min="0" max="128" step="1" value="0">
				<span id="saturation_value">0</span>
			</div>
			
			<div class="slider-decorated">
				<label for="hue">Hue:</label>
				<input type="range" id="hue" name="hue" min="-40" max="40" step="1" value="1">
				<span id="hue_value">1</span>
			</div>
			
			<div class="slider-decorated">
				<label for="gamma">Gamma:</label>
				<input type="range" id="gamma" name="gamma" min="72" max="500" step="1" value="100">
				<span id="gamma_value">100</span>
			</div>
			
			<div class="slider-decorated">
				<label for="gain">Gain:</label>
				<input type="range" id="gain" name="gain" min="0" max="100" step="1" value="0">
				<span id="gain_value">0</span>
			</div>
			
			<div class="slider-decorated">
				<label for="sharpness">Sharpness:</label>
				<input type="range" id="sharpness" name="sharpness" min="0" max="6" step="1" value="3">
				<span id="sharpness_value">6</span>
			</div> -->

			<div id="metadata" style="white-space: pre-wrap;"></div>
		</div>
	</div>	

	<div>
		<input type="checkbox" id="stream_frames" name="stream_frames" unchecked>
		<label for="stream_frames">Stream Frames</label>
	</div>

	<div>
		<input type="checkbox" id="use_base64_encoding" name="use_base64_encoding" unchecked>
		<label for="use_base64_encoding">Use base64 encoding</label>
	</div>

	<div>
		<input type="checkbox" id="send_fps_updates" name="send_fps_updates" unchecked>
		<label for="send_fps_updates">Send FPS updates</label>
	</div>

	<div id="fullscreen-display-section">
		<label for="image_url">Enter Image URL:</label>
		<input type="text" id="image_url" name="image_url" placeholder="http://example.com/image.jpg">
		<button id="fullscreen_submit_btn">Display Full Screen</button>
	</div>

	<button id="update_controls_btn">Update Controls</button>

	<!-- This control is redundant wrt the camera mode control -->
	<!-- <div>
		<label for="exposure_auto_priority">Exposure Auto Priority:</label>
		<input type="checkbox" id="exposure_auto_priority" name="exposure_auto_priority">
	</div> -->

	<!-- <div style="position: absolute; bottom: 0%; left: 6%; z-index: 10;"> -->
	<div>
		<!-- <p style="color: hsl(0, 0%, 0%); text-shadow: rgb(255, 255, 255) 0px 0px 15px;"> -->
		<p>
			Reader/Capture/Controller fps:
			<span id="image_capture_reader_fps">0</span> /
			<span id="image_capture_capture_fps">0</span> /
			<span id="system_controller_fps">0</span>
		</p>
	</div>

	<p>

	<div style="position: relative;">
		<img id="image" alt="image">
	</div>

	<script>
		// default values for host and port if they have not been previously defined
		if (typeof host === 'undefined') { var host = window.location.hostname; }
		if (typeof port === 'undefined') { var port = window.location.port; }
		var uri = 'ws://' + host + ':' + port + '/ws';
		console.log("dashboard: uri = " + uri);
		var ws = new WebSocket(uri);
		ws.binaryType = 'blob'; // Set the binaryType to 'blob'
		var throttle = false;
		var nextIsImage = false;

		ws.onopen = function (event) {
			// nothing yet
		};

		ws.onmessage = function (event) {
			if (nextIsImage && event.data instanceof Blob) {
				var imgElement = document.getElementById('image');
				if (imgElement.src !== '') {
					// console.log('Revoke blob URL:', imgElement.src); // Revoke the old object URL
					URL.revokeObjectURL(imgElement.src); // Revoke the old object URL
				}
				var url = URL.createObjectURL(event.data);
				imgElement.src = url;
				throttle = false;
				nextIsImage = false;
			} else {
				var data = JSON.parse(event.data);

				// Handle image response
				if (data.image_response) {
					if (data.image_response.image === 'next') {
						nextIsImage = true;
					} else if (data.image_response.image === 'here') {
						var imgElement = document.getElementById('image');
						var base64Image = data.image_response.image_base64;
						imgElement.src = 'data:image/jpeg;base64,' + base64Image;
						nextIsImage = false;
					}
					// Handle metadata response
					// if (data.image_response.metadata) {
					// 	document.getElementById('metadata').textContent = data.image_response.metadata;
					// }
					if (data.image_response.metadata) {
						var metadata = data.image_response.metadata;
						// var prettyMetadata = JSON.stringify(metadata, null, 2); // Pretty-print the JSON object
						// document.getElementById('metadata').textContent = prettyMetadata;

						// var metadata = data.image_response.metadata;

						// Format ScalerCrop, SensorBlackLevels, and ColourGains
						if (metadata.ScalerCrop) {
							metadata.ScalerCrop = metadata.ScalerCrop.map(x => x.toFixed(0)).join(', ');
						}
						if (metadata.SensorBlackLevels) {
							metadata.SensorBlackLevels = metadata.SensorBlackLevels.map(x => x.toFixed(0)).join(', ');
						}
						if (metadata.ColourGains) {
							metadata.ColourGains = metadata.ColourGains.map(x => x.toFixed(3)).join(', ');
						}
						if (metadata.DigitalGain) {
						    metadata.DigitalGain = metadata.DigitalGain.toFixed(3);
						}
						if (metadata.Lux) {
						    metadata.Lux = metadata.Lux.toFixed(3);
						}
						if (metadata.AnalogueGain) {
						    metadata.AnalogueGain = metadata.AnalogueGain.toFixed(3);
						}
						// Format ColourCorrectionMatrix
						if (metadata.ColourCorrectionMatrix) {
							var formattedMatrix = '';
							for (var i = 0; i < 9; i += 3) {
								formattedMatrix += metadata.ColourCorrectionMatrix.slice(i, i + 3).map(x => x.toFixed(3)).join(' ') + '; ';
							}
							metadata.ColourCorrectionMatrix = formattedMatrix.trim();
						}

						var prettyMetadata = JSON.stringify(metadata, null, 2); // Pretty-print the JSON object
						document.getElementById('metadata').textContent = prettyMetadata;
					}
				} else if (data.update_controls) {
					Object.keys(data.update_controls).forEach(function (key) {
						updateElementValue(key, data.update_controls[key]);
					});
				} else {
					// Handle updates for each control element
					Object.keys(data).forEach(function (key) {
						if (data[key] && data[key].hasOwnProperty('value')) {
							updateElementValue(key, data[key].value);
						}
					});

					// Handle FPS update
					if (data.fps_update) {
						if (data.fps_update.image_capture_reader_fps !== undefined) {
							document.getElementById('image_capture_reader_fps').textContent = data.fps_update.image_capture_reader_fps.toFixed(2);
						}
						if (data.fps_update.image_capture_capture_fps !== undefined) {
							document.getElementById('image_capture_capture_fps').textContent = data.fps_update.image_capture_capture_fps.toFixed(2);
						}
						if (data.fps_update.system_controller_fps !== undefined) {
							document.getElementById('system_controller_fps').textContent = data.fps_update.system_controller_fps.toFixed(2);
						}
					}
				}
			}
		};

		fetch('/controls')
		.then(response => response.json())
		.then(controls => {
			const controlsContainer = document.querySelector('.control-container');

			controls.forEach(control => {
				let controlElement;
				let labelElement;
				let valueElement;
				let controlWrapper;

				switch (control.type) {
					case 'IntegerControl':
					case 'FloatControl':
					case 'Integer32':
					case 'Integer64':
					case 'Float':
						controlWrapper = document.createElement('div');
						controlWrapper.className = 'slider-decorated';
						labelElement = document.createElement('label');
						labelElement.textContent = control.name;
						controlElement = document.createElement('input');
						controlElement.type = 'range';
						controlElement.min = control.range[0];
						controlElement.max = control.range[1];
						controlElement.step = control.step; // Set the step attribute based on control descriptor
						controlElement.value = control.value;
						valueElement = document.createElement('span');
						valueElement.textContent = control.value;
						valueElement.id = control.name + '_value'; // Set an ID for the value element
						controlWrapper.appendChild(labelElement);
						controlWrapper.appendChild(controlElement);
						controlWrapper.appendChild(valueElement);
						break;

					case 'BooleanControl':
					case 'Bool':
						controlWrapper = document.createElement('div');
						controlWrapper.className = 'checkbox-decorated';
						labelElement = document.createElement('label');
						labelElement.textContent = control.name;
						controlElement = document.createElement('input');
						controlElement.type = 'checkbox';
						controlElement.checked = control.value;
						valueElement = document.createElement('span');
						valueElement.textContent = control.value;
						valueElement.id = control.name + '_value'; // Set an ID for the value element
						controlWrapper.appendChild(labelElement);
						controlWrapper.appendChild(controlElement);
						controlWrapper.appendChild(valueElement);
						break;

					case 'MenuControl':
						controlWrapper = document.createElement('div');
						labelElement = document.createElement('label');
						labelElement.textContent = control.name;
						controlElement = document.createElement('select');
						control.options.forEach(option => {
							let optionElement = document.createElement('option');
							optionElement.value = option;
							optionElement.textContent = option;
							controlElement.appendChild(optionElement);
						});
						controlElement.value = control.value;
						valueElement = document.createElement('span');
						valueElement.textContent = control.value;
						valueElement.id = control.name + '_value'; // Set an ID for the value element
						controlWrapper.appendChild(labelElement);
						controlWrapper.appendChild(controlElement);
						controlWrapper.appendChild(valueElement);
						break;
					// ... handle other control types
				}

				controlElement.id = control.name;
				controlElement.name = control.name;
				controlWrapper.appendChild(controlElement);
				controlsContainer.appendChild(controlWrapper);

				// Add event listener to update value text when the control's value changes
				controlElement.addEventListener('input', function () {
					valueElement.textContent = this.value;
					// Send the updated value to the server
					if (ws.readyState == WebSocket.OPEN) {
						ws.send(JSON.stringify({
							'set_control': {
								[control.name]: (this.type === 'checkbox' ? this.checked : parseFloat(this.value))
							}
						}));
					}
				});
			});

			// XXX this does not belong here
			document.getElementById('colour_gain_red').addEventListener('input', updateColourGains);
			document.getElementById('colour_gain_blue').addEventListener('input', updateColourGains);
		})
		.catch(error => {
			console.error('Error fetching controls:', error);
		});

		document.getElementById('update_controls_btn').addEventListener('click', function () {
			if (ws.readyState == WebSocket.OPEN) {
				ws.send(JSON.stringify({ 'update_controls': {} }));
			}
		});

		function updateElementValue(elementId, newValue) {
			var element = document.getElementById(elementId);
			if (element && element.type === 'range') {
				element.value = newValue;
			}
			var valueElement = document.getElementById(elementId + '_value');
			if (valueElement) {
				valueElement.textContent = newValue;
			}
		}

		document.getElementById('sweep').addEventListener('change', function () {
			if (ws.readyState == WebSocket.OPEN) {
				ws.send(JSON.stringify({
					'sweep_enable': {
						'value': this.checked
					}
				}));
			}
		});

		document.getElementById('cam_mode').addEventListener('change', function () {
			var mode = this.checked ? 'triggered' : 'freerunning';
			if (ws.readyState == WebSocket.OPEN) {
				ws.send(JSON.stringify({
					'capture_mode': {
						'value': mode
					}
				}));
			}
		});

		document.getElementById('stream_frames').addEventListener('change', function () {
			// Send the preference to the server using the websocket connection
			ws.send(JSON.stringify({ 'stream_frames': { 'value': this.checked } }));
		});

		document.getElementById('use_base64_encoding').addEventListener('change', function () {
			// Send the preference to the server using the websocket connection
			ws.send(JSON.stringify({ 'use_base64_encoding': { 'value': this.checked } }));
		});

		document.getElementById('send_fps_updates').addEventListener('change', function () {
			// Send the preference to the server using the websocket connection
			ws.send(JSON.stringify({ 'send_fps_updates': { 'value': this.checked } }));
		});
	
		Array.from(document.querySelectorAll('input[type=range]')).forEach(function (slider) {
			slider.addEventListener('input', function () {
				var sliderId = this.id;
				var sliderValue = this.value;
				document.getElementById(sliderId + '_value').textContent = sliderValue;
				if (ws.readyState == WebSocket.OPEN) {
					ws.send(JSON.stringify({
						'set_control': {
							[sliderId]: sliderValue
						}
					}));
				}
			});
		});

		function updateColourGains() {
			var redGain = document.getElementById('colour_gain_red').value;
			var blueGain = document.getElementById('colour_gain_blue').value;
			ws.send(JSON.stringify({
				'set_control': {
					'ColourGains': [parseFloat(redGain), parseFloat(blueGain)]
				}
			}));
		}

		// document.getElementById('colour_gain_red').addEventListener('input', updateColourGains);
		// document.getElementById('colour_gain_blue').addEventListener('input', updateColourGains);


		// document.getElementById('power_line_frequency').addEventListener('change', function () {
		// 	var frequency = this.value;
		// 	if (ws.readyState == WebSocket.OPEN) {
		// 		ws.send(JSON.stringify({
		// 			'power_line_frequency': {
		// 				'value': frequency
		// 			}
		// 		}));
		// 	}
		// });

		// document.getElementById('backlight_compensation').addEventListener('input', function () {
		// 	var compensation = this.value;
		// 	document.getElementById('backlight_compensation_value').textContent = compensation;
		// 	if (ws.readyState == WebSocket.OPEN) {
		// 		ws.send(JSON.stringify({
		// 			'backlight_compensation': {
		// 				'value': parseInt(compensation)
		// 			}
		// 		}));
		// 	}
		// });

		// document.getElementById('exposure_auto').addEventListener('change', function () {
		// 	var exposureAuto = this.value;
		// 	if (ws.readyState == WebSocket.OPEN) {
		// 		ws.send(JSON.stringify({
		// 			'exposure_auto': {
		// 				'value': exposureAuto
		// 			}
		// 		}));
		// 	}
		// });

		document.getElementById('capture_mode').addEventListener('change', function () {
		    var selectedMode = this.value;
		    console.log(`Selected camera mode: ${selectedMode}`); // Log the selected mode
		    if (ws.readyState == WebSocket.OPEN) {
		        ws.send(JSON.stringify({
		            'capture_mode': {
		                'value': selectedMode
		            }
		        }));
		    }
		});

		document.getElementById('fullscreen_submit_btn').addEventListener('click', function () {
			// Get the image URL from the input
			var imageUrl = document.getElementById('image_url').value;

			// Verify WebSocket connection is open
			if (ws.readyState == WebSocket.OPEN) {
				// Send the image URL to the server via WebSocket message
				ws.send(JSON.stringify({
					'slm_image_url': imageUrl
				}));

				// Optional: Clear the input field after submission
				// document.getElementById('image_url').value = '';
			} else {
				console.error('WebSocket connection is not open.');
			}
		});

		// fetch('/controls')
		// .then(response => response.json())
		// .then(controls => {
		// 	const controlsContainer = document.getElementById('controls-container'); // Ensure this ID matches your HTML

		// 	controls.forEach(control => {
		// 		const controlElement = document.createElement('div'); // Or another appropriate HTML element
		// 		// Fill 'controlElement' with the proper HTML based on 'control' properties
		// 		// For example:
		// 		controlElement.innerHTML = `<label for="${control.name}">${control.name}</label>
		// 					<input type="${determineInputType(control)}" id="${control.name}" />`;

		// 		controlsContainer.appendChild(controlElement); // Append the newly created element to the container
		// 	});
		// })
		
		// function determineInputType(control) {
		// 	// You can implement this function to decide which input type to use
		// 	// based on the control type. This could be a simple mapper from
		// 	// control.type to 'number', 'checkbox', 'range', etc.
		// 	// This is just a placeholder function.
		// 	return 'text';
		// }


	</script>
</body>

</html>